/**
 * @file    decoder.c
 * @author  Samuel Meyers
 * @brief   Secure Decoder Implementation for eCTF design.
 *          This secure version preserves the same external interface as the original:
 *          - LIST: returns a list_response_t with each channel_info_t (channel, start, end) using 64‐bit timestamps.
 *          - SUBSCRIBE and DECODE commands use the same packet formats as the original.
 *
 *          Internally, the decoder:
 *            • Loads secure keys from a JSON file (global_secrets/secrets.json) generated by gen_secrets.
 *            • In decode(), it verifies the subscription MAC, derives a dynamic key via AES‑CMAC (“K1‑Derivation”)
 *              and uses AES‑CTR to decrypt the encrypted frame.
 *
 * @date    2025
 *
 * @copyright Copyright (c) 2025 The MITRE Corporation
 */

 #include <stdio.h>
 #include <stdint.h>
 #include <stdbool.h>
 #include <string.h>
 #include <stdlib.h>
 #include "mxc_device.h"
 #include "status_led.h"
 #include "board.h"
 #include "mxc_delay.h"
 #include "simple_flash.h"
 #include "host_messaging.h"
 #include "simple_uart.h"
 
 // WolfSSL AES
 #include "wolfssl/options.h"
 #include <wolfssl/wolfcrypt/aes.h>
 
 // We do NOT include <wolfssl/wolfcrypt/base64.h> anymore. Instead we use a custom decode_base64 below.
 
 // cJSON for parsing secrets JSON
 #include "cJSON.h"
 
 /**********************************************************
  ******************* PRIMITIVE TYPES **********************/
 #define timestamp_t uint64_t
 #define channel_id_t uint32_t
 #define decoder_id_t uint32_t
 #define pkt_len_t uint16_t
 
 /**********************************************************
  *********************** CONSTANTS ************************/
 #define MAX_CHANNEL_COUNT 8
 #define EMERGENCY_CHANNEL 0
 
 // For our secure format, we have:
 //   Header (20 bytes) + Subscription (52 bytes) + Ciphertext (24 bytes) = 96 bytes total.
 #define HEADER_SIZE       20
 #define SUBS_DATA_SIZE    36
 #define SUBS_MAC_SIZE     16
 #define SUBS_TOTAL_SIZE   (SUBS_DATA_SIZE + SUBS_MAC_SIZE)  // 52
 #define FRAME_SEC_SIZE    8
 #define TRAILER_SIZE      16
 #define CIPHER_SIZE       (FRAME_SEC_SIZE + TRAILER_SIZE)   // 24
 #define PACKET_SIZE       (HEADER_SIZE + SUBS_TOTAL_SIZE + CIPHER_SIZE) // 96
 
 // For the LIST command, we keep the original format of channel(4) + two 64-bit timestamps.
 #define DEFAULT_CHANNEL_TIMESTAMP 0xFFFFFFFFFFFFFFFFULL
 #define FLASH_FIRST_BOOT 0xDEADBEEF
 #define FLASH_STATUS_ADDR ((MXC_FLASH_MEM_BASE + MXC_FLASH_MEM_SIZE) - (2 * MXC_FLASH_PAGE_SIZE))
 
 /**********************************************************
  *********** COMMUNICATION PACKET DEFINITIONS *************/
 #pragma pack(push, 1)
 typedef struct {
     channel_id_t channel;
     timestamp_t timestamp;
     uint8_t data[FRAME_SEC_SIZE]; // 8 bytes
 } frame_packet_t;
 
 typedef struct {
     decoder_id_t decoder_id;
     timestamp_t start_timestamp;
     timestamp_t end_timestamp;
     channel_id_t channel;
 } subscription_update_packet_t;
 
 typedef struct {
     channel_id_t channel;
     timestamp_t start;
     timestamp_t end;
 } channel_info_t;
 
 typedef struct {
     uint32_t n_channels;
     channel_info_t channel_info[MAX_CHANNEL_COUNT];
 } list_response_t;
 #pragma pack(pop)
 
 /**********************************************************
  ******************** TYPE DEFINITIONS ********************/
 typedef struct {
     bool active;
     channel_id_t id;
     timestamp_t start_timestamp;
     timestamp_t end_timestamp;
 } channel_status_t;
 
 typedef struct {
     uint32_t first_boot;
     channel_status_t subscribed_channels[MAX_CHANNEL_COUNT];
 } flash_entry_t;
 
 /**********************************************************
  ************************ GLOBALS *************************/
 static flash_entry_t decoder_status;
 
 // In a real design, these are loaded from JSON. We'll store them here after parsing.
 static uint8_t G_K_MASTER[16];   // Master key (dummy or from JSON if needed)
 static uint8_t g_channel_key[32]; // Channel key (we pick one channel's key by default)
 
 static cJSON *global_secrets = NULL; // parsed secrets JSON
 
 /**********************************************************
  ****************** LOAD SECURE KEYS **********************/
 /**
  * @brief  Loads the secure keys from the JSON file located at
  *         ../design/ectf25_design/global_secrets/secrets.json
  * @return 0 on success, -1 on error
  */
 static int load_secure_keys(void)
 {
     const char *secrets_path = "../design/ectf25_design/global_secrets/secrets.json";
     FILE *f = fopen(secrets_path, "rb");
     if (!f) {
         fprintf(stderr, "[decoder] ERROR: Cannot open secrets file at %s\n", secrets_path);
         return -1;
     }
     fseek(f, 0, SEEK_END);
     long len = ftell(f);
     rewind(f);
 
     char *buffer = (char*)malloc(len + 1);
     if (!buffer) {
         fclose(f);
         fprintf(stderr, "[decoder] ERROR: Not enough memory for secrets file\n");
         return -1;
     }
     if (fread(buffer, 1, len, f) != (size_t)len) {
         fclose(f);
         free(buffer);
         fprintf(stderr, "[decoder] ERROR: Reading secrets file failed\n");
         return -1;
     }
     buffer[len] = '\0';
     fclose(f);
 
     global_secrets = cJSON_Parse(buffer);
     free(buffer);
     if (!global_secrets) {
         fprintf(stderr, "[decoder] ERROR: JSON parse of secrets file failed\n");
         return -1;
     }
 
     // Optionally read a master key from the JSON. Otherwise, set a default.
     memset(G_K_MASTER, 0xAB, sizeof(G_K_MASTER));
 
     // We'll fill g_channel_key from the JSON in init() once we pick a channel.
     return 0;
 }
 
 /**********************************************************
  ****************** BASE64 HELPER FUNCTION *****************/
 // A simple (not highly optimized) base64 decoder. 
 static const char b64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 static int decode_base64(const char* in, uint8_t *out, int out_size)
 {
     int in_len = (int)strlen(in);
     int pad = 0;
     // Count padding
     if (in_len >= 2) {
         if (in[in_len-1] == '=') pad++;
         if (in[in_len-2] == '=') pad++;
     }
     int out_len = (in_len * 3) / 4 - pad;
     if (out_len > out_size) return -1;
 
     int i = 0, j = 0;
     uint32_t buffer = 0;
     int bits_collected = 0;
 
     for (i = 0; i < in_len; i++) {
         char c = in[i];
         if (c == '=' || c == '\n' || c == '\r' || c == ' ')
             break; // stop reading
         const char *p = strchr(b64_table, c);
         if (!p) continue; // skip unrecognized chars
         buffer = (buffer << 6) | (p - b64_table);
         bits_collected += 6;
         if (bits_collected >= 8) {
             bits_collected -= 8;
             if (j < out_size) {
                 out[j++] = (uint8_t)((buffer >> bits_collected) & 0xFF);
             }
         }
     }
     return j; // number of bytes decoded
 }
 
 /**********************************************************
  ****************** CRYPTO FUNCTIONS **********************/
 /** 
  * @brief Left shift a 16-byte block by one bit (AES-CMAC subkey generation).
  */
 static void leftshift_onebit(const uint8_t* in, uint8_t* out)
 {
     uint8_t overflow = 0;
     for (int i = 15; i >= 0; i--) {
         out[i] = (in[i] << 1) | overflow;
         overflow = (in[i] & 0x80) ? 1 : 0;
     }
 }
 
 /**
  * @brief AES-ECB encrypt one block (16 bytes).
  */
 static int aes_ecb_encrypt_block(const uint8_t* key, int keyLen, const uint8_t* in, uint8_t* out)
 {
     Aes aes;
     int ret = wc_AesSetKey(&aes, key, keyLen, NULL, AES_ENCRYPTION);
     if (ret != 0) return ret;
     wc_AesEncryptDirect(&aes, out, in);
     return 0;
 }
 
 /**
  * @brief AES-CMAC (RFC4493)
  */
 static int aes_cmac(const uint8_t* key, int keyLen, const uint8_t* msg, size_t msg_len, uint8_t mac[16])
 {
     uint8_t zero_block[16] = {0};
     uint8_t L[16];
     if (aes_ecb_encrypt_block(key, keyLen, zero_block, L) != 0)
         return -1;
 
     uint8_t K1[16], K2[16];
     leftshift_onebit(L, K1);
     if (L[0] & 0x80) {
         K1[15] ^= 0x87;
     }
     leftshift_onebit(K1, K2);
     if (K1[0] & 0x80) {
         K2[15] ^= 0x87;
     }
 
     size_t n = (msg_len + 15) / 16;
     bool complete = ((msg_len % 16) == 0 && msg_len != 0);
     if (n == 0) {
         n = 1;
         complete = false;
     }
 
     uint8_t M_last[16];
     memset(M_last, 0, 16);
 
     if (complete) {
         memcpy(M_last, msg + (n - 1)*16, 16);
         for (int i = 0; i < 16; i++) {
             M_last[i] ^= K1[i];
         }
     } else {
         size_t rem = msg_len % 16;
         uint8_t temp[16];
         memset(temp, 0, 16);
         if (rem > 0) {
             memcpy(temp, msg + (n - 1)*16, rem);
         }
         temp[rem] = 0x80;
         for (int i = 0; i < 16; i++) {
             M_last[i] = temp[i] ^ K2[i];
         }
     }
 
     Aes aes;
     if (wc_AesSetKey(&aes, key, keyLen, NULL, AES_ENCRYPTION) != 0)
         return -1;
 
     uint8_t X[16];
     memset(X, 0, 16);
     uint8_t block[16];
 
     // Process all but last block
     for (size_t i = 0; i < n - 1; i++) {
         for (int j = 0; j < 16; j++) {
             block[j] = X[j] ^ msg[i*16 + j];
         }
         wc_AesEncryptDirect(&aes, X, block);
     }
     // Final
     for (int j = 0; j < 16; j++) {
         block[j] = X[j] ^ M_last[j];
     }
     wc_AesEncryptDirect(&aes, X, block);
     memcpy(mac, X, 16);
     return 0;
 }
 
 /**
  * @brief AES-CTR encryption (big-endian counter).
  */
 static void aes_ctr_xcrypt(const uint8_t* key, int keyLen, const uint8_t* nonce,
                            uint8_t* buffer, size_t length)
 {
     Aes aes;
     if (wc_AesSetKey(&aes, key, keyLen, NULL, AES_ENCRYPTION) != 0)
         return;
 
     uint8_t counter[16];
     memcpy(counter, nonce, 16);
 
     size_t blocks = length / 16;
     size_t rem = length % 16;
     uint8_t keystream[16];
 
     for (size_t i = 0; i < blocks; i++) {
         wc_AesEncryptDirect(&aes, keystream, counter);
         for (int j = 0; j < 16; j++) {
             buffer[i*16 + j] ^= keystream[j];
         }
         // increment counter (big-endian)
         for (int c = 15; c >= 0; c--) {
             counter[c]++;
             if (counter[c] != 0) break;
         }
     }
     if (rem > 0) {
         wc_AesEncryptDirect(&aes, keystream, counter);
         for (size_t j = 0; j < rem; j++) {
             buffer[blocks*16 + j] ^= keystream[j];
         }
     }
 }
 
 /**
  * @brief Store 64-bit value in big-endian order.
  */
 static void store64_be(uint64_t val, uint8_t out[8])
 {
     out[0] = (val >> 56) & 0xFF;
     out[1] = (val >> 48) & 0xFF;
     out[2] = (val >> 40) & 0xFF;
     out[3] = (val >> 32) & 0xFF;
     out[4] = (val >> 24) & 0xFF;
     out[5] = (val >> 16) & 0xFF;
     out[6] = (val >>  8) & 0xFF;
     out[7] = (val >>  0) & 0xFF;
 }
 
 /**********************************************************
  ******************* SECURE PACKET PROCESSING *************/
 static int secure_process_packet(const uint8_t* packet, size_t packet_len,
                                  uint8_t** frame_out, size_t* frame_len_out)
 {
     if (packet_len != PACKET_SIZE) {
         fprintf(stderr, "[decoder] ERROR: Paquete incorrecto (esperado %d bytes, recibido %zu)\n",
                 PACKET_SIZE, packet_len);
         return -1;
     }
 
     // Parse the header
     uint32_t seq, channel, encoder_id;
     uint64_t ts;
     memcpy(&seq, packet, 4);
     memcpy(&channel, packet + 4, 4);
     memcpy(&encoder_id, packet + 8, 4);
     memcpy(&ts, packet + 12, 8);
 
     printf("[decoder] Header => seq=%u, channel=%u, enc_id=%u, ts=%llu\n",
            seq, channel, encoder_id, (unsigned long long)ts);
     fflush(stdout);
 
     // Subscription is next 52 bytes
     const uint8_t* subs_data = packet + HEADER_SIZE;
     const uint8_t* subs_mac  = subs_data + SUBS_DATA_SIZE;
     uint8_t calc_mac[16];
     if (aes_cmac(g_channel_key, 16, subs_data, SUBS_DATA_SIZE, calc_mac) != 0) {
         fprintf(stderr, "[decoder] ERROR: CMAC de suscripción falló\n");
         return -1;
     }
     if (memcmp(calc_mac, subs_mac, 16) != 0) {
         fprintf(stderr, "[decoder] ERROR: CMAC inválido, posible manipulación\n");
         return -1;
     }
     printf("[decoder] CMAC de suscripción válido\n");
     fflush(stdout);
 
     // Derive dynamic key
     uint8_t K1[16];
     if (aes_cmac(g_channel_key, 16,
                  (const uint8_t*)"K1-Derivation", strlen("K1-Derivation"), K1) != 0) {
         fprintf(stderr, "[decoder] ERROR: Falló la derivación de K1\n");
         return -1;
     }
     uint8_t seq_channel[8];
     memcpy(seq_channel, &seq, 4);
     memcpy(seq_channel + 4, &channel, 4);
 
     uint8_t dynamic_key[16];
     if (aes_cmac(K1, 16, seq_channel, 8, dynamic_key) != 0) {
         fprintf(stderr, "[decoder] ERROR: No se pudo derivar dynamic_key\n");
         return -1;
     }
     printf("[decoder] Clave dinámica derivada correctamente\n");
     fflush(stdout);
 
     // Decrypt the ciphertext
     const uint8_t* ciphertext = packet + HEADER_SIZE + SUBS_TOTAL_SIZE;
     uint8_t* plaintext = (uint8_t*)malloc(CIPHER_SIZE);
     if (!plaintext) return -1;
 
     memcpy(plaintext, ciphertext, CIPHER_SIZE);
 
     uint8_t nonce[16];
     memset(nonce, 0, 16);
     // big-endian seq in last 8 bytes
     store64_be(seq, nonce + 8);
 
     aes_ctr_xcrypt(dynamic_key, 16, nonce, plaintext, CIPHER_SIZE);
 
     // The first 8 bytes are the frame. The next 16 are the trailer, which we ignore.
     *frame_out = (uint8_t*)malloc(FRAME_SEC_SIZE);
     if (!(*frame_out)) {
         free(plaintext);
         return -1;
     }
     memcpy(*frame_out, plaintext, FRAME_SEC_SIZE);
 
     free(plaintext);
     *frame_len_out = FRAME_SEC_SIZE;
     return 0;
 }
 
 /**********************************************************
  ********************* UTILITY FUNCTIONS ********************/
 static int is_subscribed(channel_id_t channel)
 {
     if (channel == EMERGENCY_CHANNEL) {
         return 1;
     }
     for (int i = 0; i < MAX_CHANNEL_COUNT; i++) {
         if (decoder_status.subscribed_channels[i].id == channel &&
             decoder_status.subscribed_channels[i].active) {
             return 1;
         }
     }
     return 0;
 }
 
 static void boot_flag(void)
 {
     // For debugging, we print a fixed flag (NOT_REAL_FLAG).
     print_debug("Boot Reference Flag: NOT_REAL_FLAG\n");
 }
 
 static int list_channels(void)
 {
     list_response_t resp;
     pkt_len_t len;
     resp.n_channels = 0;
 
     for (uint32_t i = 0; i < MAX_CHANNEL_COUNT; i++) {
         if (decoder_status.subscribed_channels[i].active) {
             resp.channel_info[resp.n_channels].channel =
                 decoder_status.subscribed_channels[i].id;
             resp.channel_info[resp.n_channels].start =
                 decoder_status.subscribed_channels[i].start_timestamp;
             resp.channel_info[resp.n_channels].end =
                 decoder_status.subscribed_channels[i].end_timestamp;
             resp.n_channels++;
         }
     }
     len = sizeof(resp.n_channels) + (sizeof(channel_info_t) * resp.n_channels);
     write_packet(LIST_MSG, &resp, len);
     return 0;
 }
 
 static int update_subscription(pkt_len_t pkt_len, subscription_update_packet_t *update)
 {
     if (update->channel == EMERGENCY_CHANNEL) {
         STATUS_LED_RED();
         print_error("Failed to update subscription - cannot subscribe to emergency channel\n");
         return -1;
     }
     int i;
     for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
         if (!decoder_status.subscribed_channels[i].active ||
             decoder_status.subscribed_channels[i].id == update->channel) {
             decoder_status.subscribed_channels[i].active = true;
             decoder_status.subscribed_channels[i].id = update->channel;
             decoder_status.subscribed_channels[i].start_timestamp = update->start_timestamp;
             decoder_status.subscribed_channels[i].end_timestamp   = update->end_timestamp;
             break;
         }
     }
     if (i == MAX_CHANNEL_COUNT) {
         STATUS_LED_RED();
         print_error("Failed to update subscription - max subscriptions installed\n");
         return -1;
     }
     flash_simple_erase_page(FLASH_STATUS_ADDR);
     flash_simple_write(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));
     write_packet(SUBSCRIBE_MSG, NULL, 0);
     return 0;
 }
 
 /**
  * @brief Process a decode command. 
  *        Expects a 96-byte packet (PACKET_SIZE).
  */
 static int decode(pkt_len_t pkt_len, frame_packet_t *new_frame)
 {
     uint8_t *decrypted_frame = NULL;
     size_t decrypted_len = 0;
 
     int ret = secure_process_packet(new_frame->data, PACKET_SIZE,
                                     &decrypted_frame, &decrypted_len);
     if (ret < 0) {
         STATUS_LED_RED();
         print_error("Decodificación falló\n");
         return -1;
     }
 
     // Output the decrypted frame
     write_packet(DECODE_MSG, decrypted_frame, (uint16_t)decrypted_len);
     free(decrypted_frame);
     return 0;
 }
 
 /**********************************************************
  *********************** INITIALIZATION *********************/
 static void init(void)
 {
     flash_simple_init();
     flash_simple_read(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));
 
     if (decoder_status.first_boot != FLASH_FIRST_BOOT) {
         print_debug("First boot.  Setting flash...\n");
         decoder_status.first_boot = FLASH_FIRST_BOOT;
         channel_status_t subscription[MAX_CHANNEL_COUNT];
         for (int i = 0; i < MAX_CHANNEL_COUNT; i++) {
             subscription[i].start_timestamp = DEFAULT_CHANNEL_TIMESTAMP;
             subscription[i].end_timestamp   = DEFAULT_CHANNEL_TIMESTAMP;
             subscription[i].active = false;
         }
         memcpy(decoder_status.subscribed_channels, subscription,
                MAX_CHANNEL_COUNT*sizeof(channel_status_t));
         flash_simple_erase_page(FLASH_STATUS_ADDR);
         flash_simple_write(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));
     }
 
     int ret = uart_init();
     if (ret < 0) {
         STATUS_LED_ERROR();
         while (1);
     }
 
     // Load keys from secrets JSON
     if (load_secure_keys() != 0) {
         STATUS_LED_ERROR();
         print_error("Error al cargar el archivo de secretos\n");
         while (1);
     }
 
     // Example: set g_channel_key from the JSON for channel "1"
     cJSON *ck = cJSON_GetObjectItem(global_secrets, "channel_keys");
     if (ck) {
         cJSON *key_item = cJSON_GetObjectItem(ck, "1");
         if (key_item && cJSON_IsString(key_item)) {
             const char *b64 = cJSON_GetStringValue(key_item);
             if (decode_base64(b64, g_channel_key, sizeof(g_channel_key)) < 0) {
                 fprintf(stderr, "[decoder] ERROR: base64 decode failed for channel 1\n");
                 memset(g_channel_key, 0xCD, sizeof(g_channel_key)); // fallback
             }
         } else {
             memset(g_channel_key, 0xCD, sizeof(g_channel_key)); // fallback
         }
     } else {
         memset(g_channel_key, 0xCD, sizeof(g_channel_key)); // fallback
     }
 }
 
 /**********************************************************
  ************************** MAIN LOOP **********************/
 int main(void)
 {
     init();
     print_debug("Decoder Booted!\n");
 
     while (1) {
         print_debug("Ready\n");
         STATUS_LED_GREEN();
 
         msg_type_t cmd;
         uint8_t uart_buf[1024];
         uint16_t pkt_len;
 
         int result = read_packet(&cmd, uart_buf, &pkt_len);
         if (result < 0) {
             STATUS_LED_ERROR();
             print_error("Failed to receive cmd from host\n");
             continue;
         }
 
         switch (cmd) {
         case LIST_MSG:
             STATUS_LED_CYAN();
             // If we had a "crypto_example()" we would remove or comment it out
             // since it's not actually implemented.
             boot_flag();
             list_channels();
             break;
 
         case DECODE_MSG:
             STATUS_LED_PURPLE();
             decode(pkt_len, (frame_packet_t *)uart_buf);
             break;
 
         case SUBSCRIBE_MSG:
             STATUS_LED_YELLOW();
             update_subscription(pkt_len, (subscription_update_packet_t *)uart_buf);
             break;
 
         default:
             STATUS_LED_ERROR();
             {
                 char output_buf[64];
                 snprintf(output_buf, sizeof(output_buf), "Invalid Command: %c\n", cmd);
                 print_error(output_buf);
             }
             break;
         }
     }
     return 0;
 }
 