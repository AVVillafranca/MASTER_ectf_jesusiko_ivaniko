/**
 * @file    decoder.c
 * @author  Samuel Meyers
 * @brief   Secure Decoder Implementation for eCTF design.
 *          This secure version preserves the same external interface as the original:
 *          - LIST: returns a list_response_t with each channel_info_t (channel, start, end) using 64‐bit timestamps.
 *          - SUBSCRIBE and DECODE commands use the same packet formats as the original.
 *
 *          Internally, the decoder:
 *            • Loads secure keys from a JSON file (global_secrets/secrets.json) generated by gen_secrets.
 *            • In decode(), it verifies the subscription MAC, derives a dynamic key via AES‐CMAC (“K1‑Derivation”)
 *              and uses AES‑CTR to decrypt the encrypted frame.
 *
 * @date    2025
 *
 * @copyright Copyright (c) 2025 The MITRE Corporation
 */

/*********************** INCLUDES *************************/
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include "mxc_device.h"
#include "status_led.h"
#include "board.h"
#include "mxc_delay.h"
#include "simple_flash.h"
#include "host_messaging.h"
#include "simple_uart.h"

#include "wolfssl/options.h"
#include <wolfssl/wolfcrypt/aes.h>
// Se elimina la inclusión de <wolfssl/wolfcrypt/base64.h>

// Incluimos cJSON para parsear el JSON de secretos.
#include "cJSON.h"

/**********************************************************
 ******************* PRIMITIVE TYPES **********************/
#define timestamp_t uint64_t
#define channel_id_t uint32_t
#define decoder_id_t uint32_t
#define pkt_len_t uint16_t

/**********************************************************
 *********************** CONSTANTS ************************/
#define MAX_CHANNEL_COUNT 8
#define EMERGENCY_CHANNEL 0

// Para este ejemplo seguro, usamos un frame seguro de 8 bytes y un trailer de 16 bytes,
// lo que nos da un ciphertext de 24 bytes. El paquete final se compone de:
//   Header (20 bytes) + Suscripción (52 bytes) + Ciphertext (24 bytes) = 96 bytes.
#define HEADER_SIZE       20
#define SUBS_DATA_SIZE    36
#define SUBS_MAC_SIZE     16
#define SUBS_TOTAL_SIZE   (SUBS_DATA_SIZE + SUBS_MAC_SIZE)  // 52 bytes
#define FRAME_SEC_SIZE    8
#define TRAILER_SIZE      16
#define CIPHER_SIZE       (FRAME_SEC_SIZE + TRAILER_SIZE)     // 24 bytes
#define PACKET_SIZE       (HEADER_SIZE + SUBS_TOTAL_SIZE + CIPHER_SIZE)  // 96 bytes

// For LIST command, we preserve the original types.
#define DEFAULT_CHANNEL_TIMESTAMP 0xFFFFFFFFFFFFFFFFULL
#define FLASH_FIRST_BOOT 0xDEADBEEF
#define FLASH_STATUS_ADDR ((MXC_FLASH_MEM_BASE + MXC_FLASH_MEM_SIZE) - (2 * MXC_FLASH_PAGE_SIZE))

/**********************************************************
 *********** COMMUNICATION PACKET DEFINITIONS *************/
#pragma pack(push, 1)
typedef struct {
    channel_id_t channel;
    timestamp_t timestamp;
    uint8_t data[FRAME_SEC_SIZE]; // Encrypted frame: 8 bytes (plaintext frame is 8 bytes)
} frame_packet_t;

typedef struct {
    decoder_id_t decoder_id;
    timestamp_t start_timestamp;
    timestamp_t end_timestamp;
    channel_id_t channel;
} subscription_update_packet_t;

typedef struct {
    channel_id_t channel;
    timestamp_t start;
    timestamp_t end;
} channel_info_t;

typedef struct {
    uint32_t n_channels;
    channel_info_t channel_info[MAX_CHANNEL_COUNT];
} list_response_t;
#pragma pack(pop)

/**********************************************************
 ******************** TYPE DEFINITIONS ********************/
typedef struct {
    bool active;
    channel_id_t id;
    timestamp_t start_timestamp;
    timestamp_t end_timestamp;
} channel_status_t;

typedef struct {
    uint32_t first_boot;
    channel_status_t subscribed_channels[MAX_CHANNEL_COUNT];
} flash_entry_t;

/**********************************************************
 ************************ GLOBALS *************************/
static flash_entry_t decoder_status;

// Global secure key globals. In a real design these are loaded from the JSON file.
static uint8_t G_K_MASTER[16];   // Master key (dummy or from JSON if needed)
static uint8_t g_channel_key[32];  // Global channel key (will be updated per channel as needed)

// Global pointer to the parsed secrets JSON.
static cJSON *global_secrets = NULL;

/**********************************************************
 ****************** LOAD SECURE KEYS ************************
 **********************************************************/
// Function to load the secure keys from the global secrets JSON file.
// The file is expected at the relative path "../design/ectf25_design/global_secrets/secrets.json"
int load_secure_keys(void) {
    const char *secrets_path = "../design/ectf25_design/global_secrets/secrets.json";
    FILE *f = fopen(secrets_path, "rb");
    if (!f) {
        fprintf(stderr, "[decoder] ERROR: No se pudo abrir el archivo de secretos en %s\n", secrets_path);
        return -1;
    }
    fseek(f, 0, SEEK_END);
    long len = ftell(f);
    rewind(f);
    char *buffer = malloc(len + 1);
    if (!buffer) {
        fclose(f);
        fprintf(stderr, "[decoder] ERROR: No se pudo asignar memoria para el archivo de secretos\n");
        return -1;
    }
    if (fread(buffer, 1, len, f) != (size_t)len) {
        fclose(f);
        free(buffer);
        fprintf(stderr, "[decoder] ERROR: Error leyendo el archivo de secretos\n");
        return -1;
    }
    buffer[len] = '\0';
    fclose(f);

    global_secrets = cJSON_Parse(buffer);
    free(buffer);
    if (!global_secrets) {
        fprintf(stderr, "[decoder] ERROR: No se pudo parsear el archivo JSON de secretos\n");
        return -1;
    }
    // (Opcionalmente, podríamos cargar aquí G_K_MASTER si se define en el JSON, de lo contrario usamos valor fijo)
    memset(G_K_MASTER, 0xAB, 16);
    // Para g_channel_key se establecerá en _get_channel_key según el canal.
    return 0;
}

/**********************************************************
 ****************** BASE64 HELPER FUNCTION ******************
 **********************************************************/
// Implementación sencilla de decodificación Base64 (no optimizada)
static const char b64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static int decode_base64(const char* in, uint8_t *out, int out_size) {
    int in_len = (int)strlen(in);
    int i = 0, j = 0;
    int pad = 0;
    // Contar padding
    if (in_len >= 2) {
        if (in[in_len-1] == '=') pad++;
        if (in[in_len-2] == '=') pad++;
    }
    int out_len = (in_len * 3) / 4 - pad;
    if (out_len > out_size) return -1;

    uint32_t buffer = 0;
    int bits_collected = 0;
    for (i = 0; i < in_len; i++) {
        char c = in[i];
        if (c == '=' || c == '\n' || c == '\r' || c == ' ')
            break;
        const char *p = strchr(b64_table, c);
        if (!p) continue;
        buffer = (buffer << 6) | (p - b64_table);
        bits_collected += 6;
        if (bits_collected >= 8) {
            bits_collected -= 8;
            if (j < out_size)
                out[j++] = (uint8_t)((buffer >> bits_collected) & 0xFF);
        }
    }
    return j;
}

/**********************************************************
 ****************** CRYPTO FUNCTIONS ************************
 **********************************************************/
// Left shift a 16-byte block by one bit.
static void leftshift_onebit(const uint8_t* in, uint8_t* out) {
    uint8_t overflow = 0;
    for (int i = 15; i >= 0; i--) {
        out[i] = (in[i] << 1) | overflow;
        overflow = (in[i] & 0x80) ? 1 : 0;
    }
}

// Encrypt a single block in ECB mode.
static int aes_ecb_encrypt_block(const uint8_t* key, int keyLen, const uint8_t* in, uint8_t* out) {
    Aes aes;
    int ret = wc_AesSetKey(&aes, key, keyLen, NULL, AES_ENCRYPTION);
    if (ret != 0) return ret;
    wc_AesEncryptDirect(&aes, out, in);
    return 0;
}

// AES-CMAC implementation (RFC4493)
static int aes_cmac(const uint8_t* key, int keyLen, const uint8_t* msg, size_t msg_len, uint8_t mac[16]) {
    uint8_t zero_block[16] = {0};
    uint8_t L[16];
    if (aes_ecb_encrypt_block(key, keyLen, zero_block, L) != 0)
        return -1;
    uint8_t K1[16], K2[16];
    leftshift_onebit(L, K1);
    if (L[0] & 0x80) {
        K1[15] ^= 0x87;
    }
    leftshift_onebit(K1, K2);
    if (K1[0] & 0x80) {
        K2[15] ^= 0x87;
    }
    size_t n = (msg_len + 15) / 16;
    bool complete = ((msg_len % 16) == 0 && msg_len != 0);
    if (n == 0) {
        n = 1;
        complete = false;
    }
    uint8_t M_last[16] = {0};
    if (complete) {
        memcpy(M_last, msg + (n - 1) * 16, 16);
        for (int i = 0; i < 16; i++) {
            M_last[i] ^= K1[i];
        }
    } else {
        size_t rem = msg_len % 16;
        uint8_t temp[16] = {0};
        if (rem > 0) {
            memcpy(temp, msg + (n - 1) * 16, rem);
        }
        temp[rem] = 0x80;
        for (int i = 0; i < 16; i++) {
            M_last[i] = temp[i] ^ K2[i];
        }
    }
    Aes aes;
    if (wc_AesSetKey(&aes, key, keyLen, NULL, AES_ENCRYPTION) != 0)
        return -1;
    uint8_t X[16] = {0};
    uint8_t block[16];
    for (size_t i = 0; i < n - 1; i++) {
        for (int j = 0; j < 16; j++) {
            block[j] = X[j] ^ msg[i*16 + j];
        }
        wc_AesEncryptDirect(&aes, X, block);
    }
    for (int j = 0; j < 16; j++) {
        block[j] = X[j] ^ M_last[j];
    }
    wc_AesEncryptDirect(&aes, X, block);
    memcpy(mac, X, 16);
    return 0;
}

// AES-CTR encryption (big-endian counter).
static void aes_ctr_xcrypt(const uint8_t* key, int keyLen, const uint8_t* nonce, uint8_t* buffer, size_t length) {
    Aes aes;
    if (wc_AesSetKey(&aes, key, keyLen, NULL, AES_ENCRYPTION) != 0)
        return;
    uint8_t counter[16];
    memcpy(counter, nonce, 16);
    size_t blocks = length / 16;
    size_t rem = length % 16;
    uint8_t keystream[16];
    for (size_t i = 0; i < blocks; i++) {
        wc_AesEncryptDirect(&aes, keystream, counter);
        for (int j = 0; j < 16; j++) {
            buffer[i * 16 + j] ^= keystream[j];
        }
        for (int c = 15; c >= 0; c--) {
            counter[c]++;
            if (counter[c] != 0) break;
        }
    }
    if (rem > 0) {
        wc_AesEncryptDirect(&aes, keystream, counter);
        for (size_t j = 0; j < rem; j++) {
            buffer[blocks*16 + j] ^= keystream[j];
        }
    }
}

// Store a 64-bit value in big-endian order.
static void store64_be(uint64_t val, uint8_t out[8]) {
    out[0] = (val >> 56) & 0xff;
    out[1] = (val >> 48) & 0xff;
    out[2] = (val >> 40) & 0xff;
    out[3] = (val >> 32) & 0xff;
    out[4] = (val >> 24) & 0xff;
    out[5] = (val >> 16) & 0xff;
    out[6] = (val >> 8) & 0xff;
    out[7] = (val >> 0) & 0xff;
}

/**********************************************************
 ******************* SECURE PACKET PROCESSING *************/
static int secure_process_packet(const uint8_t* packet, size_t packet_len,
                                 uint8_t** frame_out, size_t* frame_len_out) {
    if (packet_len != PACKET_SIZE) {
        fprintf(stderr, "[decoder] ERROR: Paquete incorrecto (esperado %d bytes, recibido %zu bytes)\n", PACKET_SIZE, packet_len);
        return -1;
    }
    uint32_t seq, channel, encoder_id;
    uint64_t ts;
    memcpy(&seq, packet, 4);
    memcpy(&channel, packet + 4, 4);
    memcpy(&encoder_id, packet + 8, 4);
    memcpy(&ts, packet + 12, 8);
    printf("[decoder] Header => seq=%u, channel=%u, enc_id=%u, ts=%llu\n",
           seq, channel, encoder_id, (unsigned long long)ts);
    fflush(stdout);
    const uint8_t* subs_data = packet + HEADER_SIZE;
    const uint8_t* subs_mac  = subs_data + SUBS_DATA_SIZE;
    uint8_t calc_mac[16];
    if (aes_cmac(g_channel_key, 16, subs_data, SUBS_DATA_SIZE, calc_mac) != 0) {
        fprintf(stderr, "[decoder] ERROR: CMAC de suscripción falló\n");
        return -1;
    }
    if (memcmp(calc_mac, subs_mac, 16) != 0) {
        fprintf(stderr, "[decoder] ERROR: CMAC inválido, posible manipulación\n");
        return -1;
    }
    printf("[decoder] CMAC de suscripción válido\n");
    fflush(stdout);
    uint8_t K1[16];
    if (aes_cmac(g_channel_key, 16, (uint8_t*)"K1-Derivation", strlen("K1-Derivation"), K1) != 0) {
        fprintf(stderr, "[decoder] ERROR: Falló la derivación de K1\n");
        return -1;
    }
    uint8_t seq_channel[8];
    memcpy(seq_channel, &seq, 4);
    memcpy(seq_channel + 4, &channel, 4);
    uint8_t dynamic_key[16];
    if (aes_cmac(K1, 16, seq_channel, 8, dynamic_key) != 0) {
        fprintf(stderr, "[decoder] ERROR: No se pudo derivar dynamic_key\n");
        return -1;
    }
    printf("[decoder] Clave dinámica derivada correctamente\n");
    fflush(stdout);
    const uint8_t* ciphertext = packet + HEADER_SIZE + SUBS_TOTAL_SIZE;
    uint8_t* plaintext = (uint8_t*)malloc(CIPHER_SIZE);
    if (!plaintext) return -1;
    memcpy(plaintext, ciphertext, CIPHER_SIZE);
    uint8_t nonce[16] = {0};
    store64_be(seq, nonce+8);
    aes_ctr_xcrypt(dynamic_key, 16, nonce, plaintext, CIPHER_SIZE);
    *frame_out = (uint8_t*)malloc(FRAME_SEC_SIZE);
    if (!*frame_out) {
        free(plaintext);
        return -1;
    }
    memcpy(*frame_out, plaintext, FRAME_SEC_SIZE);
    free(plaintext);
    *frame_len_out = FRAME_SEC_SIZE;
    return 0;
}

/**********************************************************
 ********************* UTILITY FUNCTIONS ********************/
int is_subscribed(channel_id_t channel) {
    if (channel == EMERGENCY_CHANNEL)
        return 1;
    for (int i = 0; i < MAX_CHANNEL_COUNT; i++) {
        if (decoder_status.subscribed_channels[i].id == channel &&
            decoder_status.subscribed_channels[i].active)
            return 1;
    }
    return 0;
}

void boot_flag(void) {
    // For debugging, we print a fixed flag. (Este flag no se usará en producción)
    print_debug("Boot Reference Flag: NOT_REAL_FLAG\n");
}

int list_channels(void) {
    list_response_t resp;
    pkt_len_t len;
    resp.n_channels = 0;
    for (uint32_t i = 0; i < MAX_CHANNEL_COUNT; i++) {
        if (decoder_status.subscribed_channels[i].active) {
            resp.channel_info[resp.n_channels].channel = decoder_status.subscribed_channels[i].id;
            resp.channel_info[resp.n_channels].start = decoder_status.subscribed_channels[i].start_timestamp;
            resp.channel_info[resp.n_channels].end = decoder_status.subscribed_channels[i].end_timestamp;
            resp.n_channels++;
        }
    }
    len = sizeof(resp.n_channels) + (sizeof(channel_info_t) * resp.n_channels);
    write_packet(LIST_MSG, &resp, len);
    return 0;
}

int update_subscription(pkt_len_t pkt_len, subscription_update_packet_t *update) {
    int i;
    if (update->channel == EMERGENCY_CHANNEL) {
        STATUS_LED_RED();
        print_error("Failed to update subscription - cannot subscribe to emergency channel\n");
        return -1;
    }
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
        if (decoder_status.subscribed_channels[i].id == update->channel ||
            !decoder_status.subscribed_channels[i].active) {
            decoder_status.subscribed_channels[i].active = true;
            decoder_status.subscribed_channels[i].id = update->channel;
            decoder_status.subscribed_channels[i].start_timestamp = update->start_timestamp;
            decoder_status.subscribed_channels[i].end_timestamp = update->end_timestamp;
            break;
        }
    }
    if (i == MAX_CHANNEL_COUNT) {
        STATUS_LED_RED();
        print_error("Failed to update subscription - max subscriptions installed\n");
        return -1;
    }
    flash_simple_erase_page(FLASH_STATUS_ADDR);
    flash_simple_write(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));
    write_packet(SUBSCRIBE_MSG, NULL, 0);
    return 0;
}

int decode(pkt_len_t pkt_len, frame_packet_t *new_frame) {
    char output_buf[128] = {0};
    uint8_t *decrypted_frame = NULL;
    size_t decrypted_len = 0;
    int ret = secure_process_packet(new_frame->data, PACKET_SIZE, &decrypted_frame, &decrypted_len);
    if (ret < 0) {
        STATUS_LED_RED();
        print_error("Decodificación falló\n");
        return -1;
    }
    write_packet(DECODE_MSG, decrypted_frame, (uint16_t)decrypted_len);
    free(decrypted_frame);
    return 0;
}

/**********************************************************
 *********************** INITIALIZATION *********************/
void init(void) {
    int ret;
    flash_simple_init();
    flash_simple_read(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));
    if (decoder_status.first_boot != FLASH_FIRST_BOOT) {
        print_debug("First boot.  Setting flash...\n");
        decoder_status.first_boot = FLASH_FIRST_BOOT;
        channel_status_t subscription[MAX_CHANNEL_COUNT];
        for (int i = 0; i < MAX_CHANNEL_COUNT; i++){
            subscription[i].start_timestamp = DEFAULT_CHANNEL_TIMESTAMP;
            subscription[i].end_timestamp = DEFAULT_CHANNEL_TIMESTAMP;
            subscription[i].active = false;
        }
        memcpy(decoder_status.subscribed_channels, subscription, MAX_CHANNEL_COUNT*sizeof(channel_status_t));
        flash_simple_erase_page(FLASH_STATUS_ADDR);
        flash_simple_write(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));
    }
    ret = uart_init();
    if (ret < 0) {
        STATUS_LED_ERROR();
        while (1);
    }
    // Load secure keys from the global secrets file.
    if (load_secure_keys() != 0) {
        STATUS_LED_ERROR();
        print_error("Error al cargar el archivo de secretos\n");
        while (1);
    }
    // Set g_channel_key using the JSON for channel "1" (or default channel)
    {
        cJSON *ck = cJSON_GetObjectItem(global_secrets, "channel_keys");
        if (ck) {
            cJSON *key_item = cJSON_GetObjectItem(ck, "1");
            if (key_item && cJSON_IsString(key_item)) {
                const char *b64 = cJSON_GetStringValue(key_item);
                if (decode_base64(b64, g_channel_key, sizeof(g_channel_key)) < 0) {
                    fprintf(stderr, "[decoder] ERROR: Falló la decodificación base64 de la clave del canal 1\n");
                    memset(g_channel_key, 0xCD, sizeof(g_channel_key)); // fallback
                }
            } else {
                memset(g_channel_key, 0xCD, sizeof(g_channel_key)); // fallback
            }
        } else {
            memset(g_channel_key, 0xCD, sizeof(g_channel_key)); // fallback
        }
    }
}

/**********************************************************
 ************************** MAIN LOOP ************************
 **********************************************************/
int main(void) {
    char output_buf[128] = {0};
    uint8_t uart_buf[1024];
    msg_type_t cmd;
    int result;
    uint16_t pkt_len;
    init();
    print_debug("Decoder Booted!\n");
    while (1) {
        print_debug("Ready\n");
        STATUS_LED_GREEN();
        result = read_packet(&cmd, uart_buf, &pkt_len);
        if (result < 0) {
            STATUS_LED_ERROR();
            print_error("Failed to receive cmd from host\n");
            continue;
        }
        switch (cmd) {
            case LIST_MSG:
                STATUS_LED_CYAN();
#ifdef CRYPTO_EXAMPLE
                crypto_example();
#endif
                boot_flag();
                list_channels();
                break;
            case DECODE_MSG:
                STATUS_LED_PURPLE();
                decode(pkt_len, (frame_packet_t *)uart_buf);
                break;
            case SUBSCRIBE_MSG:
                STATUS_LED_YELLOW();
                update_subscription(pkt_len, (subscription_update_packet_t *)uart_buf);
                break;
            default:
                STATUS_LED_ERROR();
                sprintf(output_buf, "Invalid Command: %c\n", cmd);
                print_error(output_buf);
                break;
        }
    }
    return 0;
}
